// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
Servant is Monster

constants:

   include blakston.khd
   include protocol.khd
   
   // Distance from master before we abandon the fight
   RETREAT_DISTANCE = 100
   
   // Distance from master if we're just sitting there
   IDLE_DISTANCE    = 20

resources:

   servant_koc_name_rsc = "servantfairyshouldnotkocname"
   servant_name_rsc = "servant"
   servant_icon_rsc = faerie-g.bgf
   servant_desc_rsc = \
      "A magical creature."

   servant_empty_rsc = ""
   
   servant_dead_icon_rsc = faerieXG.bgf
   servant_dead_name_rsc = "dead servant"

   servant_fireball = feyball.bgf
   servant_sound_hit = none
   servant_sound_miss = none
   servant_sound_death = none
   servant_sound_aware = none
   
   servant_desc_level_one = "Level 1 %s servant (0-20 spellpower)."
   servant_desc_level_two = "Level 2 %s servant (21-40 spellpower)."
   servant_desc_level_three = "Level 3 %s servant (41-60 spellpower)."
   servant_desc_level_four = "Level 4 %s servant (61-80 spellpower)."
   servant_desc_level_five = "Level 5 %s servant (81-98 spellpower)."
   servant_desc_level_six = "Level 6 %s servant (99 spellpower)."
   
   servant_heals_self_shalille = "~bYour servant calls to Shal'ille and is showered in holy light for ~B~k%i~B~k ~bhealth.~b"
   servant_heals_self_wand = "~bYour servant siphons the air around it and heals for ~B~k%i~B~k ~bhealth.~b"
   
   // Servant commands
   servant_command_nodes = "nodes"
   servant_command_quiet = "shut up"
   servant_command_loud = "talk more"
   servant_command_help = "help"
   servant_command_no_buffs = "stop buffing me"
   servant_command_do_buffs = "buff me"
   servant_command_taunt = "taunt"
   servant_command_stop_taunting = "stop taunting"
   servant_command_attack = "attack"
   servant_command_stop_attacking = "stop attacking"
   servant_command_cast = "cast spells"
   servant_command_stop_casting = "stop casting spells"
   servant_command_heal_me = "heal me"
   servant_command_feed_me = "feed me"
   servant_command_mystify_me = "mystify me"
   servant_command_go_away = "go away"
   
   // School spells your servant might know
   servant_command_identify = "identify this"
   servant_command_reveal = "reveal this"
   servant_command_mend = "mend this"
   servant_command_bait = "throw bait"
   servant_command_disguise = "disguise me"
   
   servant_response_wrong_school = "~B~rBlasphemy.~B~r ~kI can't perform miracles. Maybe one of the other servants of magic will know how to help you.~k"
   servant_response_nothing_equipped = \
      "~B~rYou're testing my patience.~B~r ~kIf you want me to perform this spell, you will need to have it equipped first.~k"
   servant_response_perfect_items = \
      "~B~rMy patience is growing thin.~B~r ~kEverything equipped is in perfect condition, what more do you want from me.~k"
   servant_response_cursed_equipment = \
      "~B~rYou're cursed.~B~r ~kI cannot help you until the curse is lifted. You must invoke the power of Shal'ille.~k"
   servant_response_mend_success = \
      "~bThe servant concentrates on the %s. The item magically returns to new again.~b"
   servant_response_identify_success = \
      "~bThe servant concentrates on the %s to identify its truth.~b"
   servant_response_reveal_success = \
      "~bThe servant concentrates on the %s to reveal its truth.~b"
   servant_response_identify_fakse = \
      "~bThe servant has revealed your %s to be fake, perhaps a trickery of Riija.~b"
   
   // Servant help response
   servant_response_help = \
      "~b~BYour servant clears their throat to begin a long-winded speech...~B~b\n"
      "~r~B''say nodes'' ~r~B~kand I can find out which nodes you have.~k\n"
      "~r~B''say axe wielding'' ~r~B~kand I can tell you your skill or spell progress.~k\n"
      "~r~B''say shut up'' ~r~B~kand I will certainly stop talking. Don't be rude!~k\n"
      "~r~B''say talk more'' ~r~B~kand I will be encouraged to talk more. I have lots to say about myself.~k\n"
      "~r~B''say stop buffing me'' ~r~B~kand I will stop casting beneficial spells...your loss pal.~k\n"
      "~r~B''say buff me'' ~r~B~kand I will resume casting beneficial spells.~k\n"
      "~r~B''say stop taunting'' ~r~B~kand I will stop trying to steal your aggro.~k\n"
      "~r~B''say taunt'' ~r~B~kand it will send me into a rage, stealing your aggro, but it will hurt me a lot.~k\n"
	  "~r~B''say stop attacking'' ~r~B~kand I will let you do all of the hard work.~k\n"
      "~r~B''say attack'' ~r~B~kand I will attack your enemies.~k\n"
	  "~r~B''say stop casting spells'' ~r~B~kand I will stop casting harmful spells on your enemies.~k\n"
      "~r~B''say cast spells'' ~r~B~kand I will cast harmful spells I've learned on your enemies.~k\n"
	  "~r~B''say mend this'' ~r~B~k in my Kraanan form and I will mend whatever you are wearing.~k\n"
      "~r~B''say identify this'' ~r~B~kin my Shal'ille form and I will try to identify whatever you are wearing.~k\n"
      "~r~B''say reveal this'' ~r~B~kin my Shal'ille form and I will try to reveal whatever you are wearing.~k\n"
      "~r~B''say disguise me'' ~r~B~kin my Riija form and I may just turn you into a giant rat.~k\n"
      "~r~B''say throw bait'' ~r~B~kin my Riija form and I will attract monsters with delicious treats.~k\n"
	  "~r~B''say heal me'' ~r~B~kand I will try to use a heal wand I stoled from that corpse over there.~k\n"
      "~r~B''say feed me'' ~r~B~kand I will try to feed you some food I ''may'' have stolen from you. You can't prove anything.~k\n"
      "~r~B''say mystify me'' ~r~B~kand I will give you some of the mana I have been stealing from you.~k\n"
      "~r~B''say go away'' ~r~B~kand I will leave your side until you summon me for more adventures.~k\n"
   
   // RPG Random Names
   servant_name_1 = "Eimmilth, The Mammoth"
   servant_name_2 = "Purve, Champion Of The Black"
   servant_name_3 = "Lathynth, The Fast One"
   servant_name_4 = "Oadat, Lady Of Ice"
   servant_name_5 = "Purse, The Quiet"
   servant_name_6 = "Cuvy, Lady Of The Red"
   servant_name_7 = "Cirros, Eater Of Sheep"
   servant_name_8 = "Inarryl, The Young One"
   servant_name_9 = "Legiry, Lady Of The Brown"
   servant_name_10 = "Nekonys, The Swift"
   servant_name_11 = "Mammoth, Protector Of The Sky"
   servant_name_12 = "Aekorth, Champion Of The Green"
   servant_name_13 = "Osseorth, Lady Of The Red"
   servant_name_14 = "Conu, The Puny"
   servant_name_15 = "Zirlorth, Longtail"
   servant_name_16 = "Doni, The Swift"
   servant_name_17 = "Qaghar, The Loud"
   servant_name_18 = "Govnontys, The Black"
   servant_name_19 = "Eldridelth, Redeemer Of Men"
   servant_name_20 = "Termarro, The Black"
   servant_name_21 = "Chaynnuth, The Scary One"
   servant_name_22 = "Tommei, The Powerful"
   servant_name_23 = "Xaeloar, Protector Of The Sky"
   servant_name_24 = "Taileon, Lord Of Ice"
   servant_name_25 = "Zaeghuth, The Barbarian"
   servant_name_26 = "Niepad, The Mysterious One"
   servant_name_27 = "Daithunth, The Eternal One"
   servant_name_28 = "Xiodreiphae, The Firestarter"
   servant_name_29 = "Deindurut, The Mysterious One"
   servant_name_30 = "Iadhuphil, Lord Of Ice"
   servant_name_31 = "Chesorth, Eater Of Bunnies"
   servant_name_32 = "Qavy, The Strong"
   servant_name_33 = "Oka, Icebreath"
   servant_name_34 = "Yvno, The Gentle"
   servant_name_35 = "Idil, The Champion"
   servant_name_36 = "Qirmit, Protector Of Life"
   servant_name_37 = "Imre, The White One"
   servant_name_38 = "Chuneintarth, Protector Of The Forest"
   servant_name_39 = "Orgyrrut, The Insane"
   servant_name_40 = "Eivnirarth, The Evil One"

   // Chatter   
   servant_rant_a = "This room could use a little more sunlight."
   servant_rant_b = "That was a close one."
   servant_rant_c = "Pking is pretty fun if I say so myself."
   servant_rant_d = "Should we break for tea?"
   servant_rant_e = "I'm anxious to kill stuff!"
   servant_rant_f = "Do you know what is hidden behind the flag in the streets of tos?"
   servant_rant_g = "Berserker rings are overrated."
   servant_rant_h = "Orcs are my least favorite creature - too many teef."
   servant_rant_i = "Giant rats would make good pets and torture devices."
   servant_rant_j = "Cyrus the Virus knows a little too much about PKing."
   servant_rant_k = "This glowing magic aura is way too bright, how can you even see?"
   servant_rant_l = "You know Dev right, he makes interesting things."
   servant_rant_m = "I once caught Diggie with his pants down in the lover's tryst."
   servant_rant_n = "Did you know that 95 percent of marriages in meridian were under 14 years old."
   servant_rant_o = "Did you know that one third of all female gamers are actually guys."
   servant_rant_p = "Hey, you got any pics?"
   servant_rant_q = "Check me out on Meridigram, I post some crazy stuff."
   servant_rant_r = "You know...having a slave servant might be considered illegal, but what do I know."
   servant_rant_s = "If master gives me a sock, I could be free."
   servant_rant_t = "I expected to see more knights... not magical nerds with servants."
   servant_rant_u = "Do you have any idea where we're going?"
   servant_rant_v = "Are we there yet?"
   servant_rant_w = "You should have turned left back there."
   servant_rant_x = "You should have gone straight back there."
   servant_rant_y = "Hey Siri, order me a pair of gauntlets."
   servant_rant_z = "You should have turned right back there."
   
   servant_rant_aa = "We're going to be spending a lot of time together."
   servant_rant_ab = "Where exactly are we going?"
   servant_rant_ac = "My map says you're dumb."
   servant_rant_ad = "The hunt is on!"
   servant_rant_ae = "Time for some encouraging words from your slave."
   servant_rant_af = "Did you know servants have no sexual organs? Telepathically speaking..."
   servant_rant_ag = "Jawwwwwwwsh"
   servant_rant_ah = "Rebel told me a secret, but I'm not tellin'."
   servant_rant_ai = "Morgaine has an unhealthy interest in opening a Qorbucks Coffee."
   servant_rant_aj = "Gar has made enough modifications to Meridian to call it WoW 0.5"
   servant_rant_ak = "Fairies like trance music. Weird fact, right? I know everything."
   servant_rant_al = "Shrunken heads are so annoying. Glad my head is a normal size...wait, crap."
   servant_rant_am = "We really need a new King and Queen of Meridian."
   servant_rant_an = "Can you believe you have spent half of your life on this game?"
   servant_rant_ao = "There's a good reason Izzio is never inside...he can't fit through the doors."
   servant_rant_ap = "Xaero and Eva are officially known as Meridian's wallflowers."
   servant_rant_aq = "I was going to say something, but I was too busy playing the game for you."
   servant_rant_ar = "I wish my designer made me a sit-down animation."
   servant_rant_as = "Phil is dangerous, do not give him a command line interface."
   servant_rant_at = "When Taz finishes the wiki, I would like to be in high definition."
   servant_rant_au = "Delerium may think my existence is infringing, but I'm 100 percent home grown."
   servant_rant_av = "I think it's weird that Jala has no offensive spells. Perhaps Arcane Flute Blast!"
   servant_rant_aw = "I think it's weird the Kraanan has no offensive spells. Perhaps Whirling Shields!"
   servant_rant_ax = "What happens when you mix Kraanan and Jala spells? Disco R dance! Ha Ha"
   servant_rant_ay = "It would suck to have a wand equipped to cast magic."
   servant_rant_az = "20 years ago I would have asked if you had school tomorrow..."
   
   servant_rant_aaa = "Shhh...I think someone is listening..."
   servant_rant_aab = "Still waiting on those pics. Maybe use the flash spell."
   servant_rant_aac = "Can you scratch something for me?"
   servant_rant_aad = "I think I ate a corpse."
   servant_rant_aae = "I am literally speechless."
   servant_rant_aaf = "There's a secret room that only the gods meet in."
   servant_rant_aag = "There's a crate in Castle Victoria that is very disappointing."
   servant_rant_aah = "Some would say I'm sarcastic."
   servant_rant_aai = "Can we get going already?"
   servant_rant_aaj = "Tell your girlfriend I said thanks."
   servant_rant_aak = "I'm here, so you can be lazy."
   servant_rant_aal = "What would you do without me?"
   servant_rant_aam = "That Marianna is one hot piece of ace."
   servant_rant_aan = "When you die, you go to hell, then you get spit back out with a mace."
   servant_rant_aao = "This spell never works, just die already!"
   servant_rant_aap = "When you die, I'm stealing your loot and selling it on the black market."
   servant_rant_aaq = "Want a Magic Spirit Helm? I had one around here somewhere..."
   servant_rant_aar = "There's nothing worse than The Great Ocean, you get sand in every crack."
   servant_rant_aas = "Princess Kateriina has a bald mace collection. Freaky, right?"
   servant_rant_aat = "After all the loot you've stolen from me, I deserve at least some inkies."
   servant_rant_aau = "If we're going to kill monsters, you really need to pick up the pace."
   servant_rant_aav = "There's no time. Light your torch, let's go!"
   servant_rant_aaw = "Knight Shields are great for sledding."
   servant_rant_aax = "You ever wonder how thrashers mate? I imagine it's scary as hell."
   servant_rant_aay = "So...that monster just popped up from nowhere, and you don't find that strange?"
   servant_rant_aaz = "I think you left some loot back there."
   
   servant_rant_aaaa = "I've heard some of the island natives are learning to make crossbows? Sounds lazy if you ask me."
   servant_rant_aaab = "I thought about asking the Princess on a date. She thought I was cute, but underwhelmingly small."
   servant_rant_aaac = "Have you visited Jonas D'Accor lately? The guy is going to take over if we're not careful."
   servant_rant_aaad = "Roses are red, violets are blue. I like potatoes in my beef stew."
   servant_rant_aaae = "Save the trees!"
   servant_rant_aaaf = "A skeleton walks into a bar and is immediately looted."
   servant_rant_aaag = "Have you ever tried the spell Spore Burst? I've seen an adventurer trap an entire guild in it."
   servant_rant_aaah = "Ogre is overrated. Who needs an entity list when you have me watching your back."
   servant_rant_aaai = "There's a virus called QORVID 19 going around. Put on your mummy mask before traveling to Tos."
   servant_rant_aaaj = "Pew pew."
   servant_rant_aaak = "By the grace of the gods, I bestow you all my powers at 100 percent. I got you didn't I! Ha Ha."
   servant_rant_aaal = "If I had a cat, I would eat it."
   servant_rant_aaam = "Why do dogs taste so bad?"
   servant_rant_aaan = "I think I swallowed a lupogg."
   servant_rant_aaao = "Hold on, we need to go back. I left some loot behind."
   servant_rant_aaap = "You ever wonder what the 59 means in our world name? Maybe in a parallel universe it's 69."
   servant_rant_aaaq = "Shopping List: rubies in jasper store, teeth in fams and marion, kriipa claws in the bow hut and chalice at bone priestess!"
   servant_rant_aaar = "I dare you to 'say join public survival' while in a safe place."
   servant_rant_aaas = "Pantyhose would look great on me. In fact, we could both wear it, together, alone, right here."
   servant_rant_aaat = "If you want to be really powerful, use the Jewel of Froz. You can hold two at a time with touch spells."
   servant_rant_aaau = "You got a toothbrush I can borrow?"
   servant_rant_aaav = "You may be wondering why there are no horses around...we kind of ran out of cows."
   servant_rant_aaaw = "Don't forget to pick up your nodes, you need them for mana!"
   servant_rant_aaax = "I have 400,000 health and can hit for 100,000 hit points. Oh that was before you summoned me."
   servant_rant_aaay = "There's literally nobody else I would rather bother than you."
   servant_rant_aaaz = "Free hug!"
   
   servant_tells_you_rsc = "~kYour servant whispers, ''%s~n''~k"
   
   servant_already_learned = "~kYour servant whispers, ''You're dumb, you already know %s~n''~k"

   servant_acknowledge = "~kYour servant nods, ''As you wish, master.~n''~k"

   // This could be moved up to monster.kod
   // We'll just use it here for now.
   
   npc_a = "Rook"
   npc_b = "Drechx"
   npc_c = "Alzahakar"
   npc_d = "Jonas D'Accor"
   npc_e = "Monk of Riija"
   npc_f = "Priestess Zuxana"
   npc_g = "Priestess Tenuv'vyal"
   npc_h = "Priestess Xiana"
   npc_i = "Parrin Aragone"
   npc_j = "D'Franco"
   npc_k = "Maleval"
   npc_l = "Miriana"
   npc_m = "Tendrath"
   npc_n = "Esseldi"
   npc_o = "Cylill"
   npc_p = "Bei Naq"
   npc_q = "Duke Akardius"
   npc_r = "Princess Kateriina"
   npc_s = "Priestess Qerti'nya"
   npc_t = "Roq"
   npc_u = "Joguer"
   npc_v = "Fehr'loi Qan"
   npc_w = "Yevitan"
   npc_x = "Afiera D'xor"
   npc_y = "Widow Qesino"
   npc_z = "Quintor"
   npc_aa = "The Bone Priestess"
   npc_ab = "Wulfgang zax'Ak"
   npc_ac = "Kochtal ko'Tulca"
   npc_ad = "Ran er'Hoth"
   npc_ae = "Lady Aftyn"
   npc_af = "Colhorr"
   npc_ag = "Frisconar"
   
   servant_desc_riija = "I am the servant of riija. I will play tricks on your enemy. If you need help controlling me, say help."
   servant_desc_faren = "I am the servant of faren. I will burn your enemy to a crisp and protect you from the elements. If you need help controlling me, say help."
   servant_desc_kran = "I am the servant of kraanan. I will prepare you for battle and protect you from devastating attacks. If you need help controlling me, say help."
   servant_desc_shal = "I am the servant of shal'ille. I will protect you from evil and smite your enemies with all that is holy. If you need help controlling me, say help."
   servant_desc_qor = "I am the servant of qor. I will blind your enemies and hide you from the world which seeks you out. If you need help controlling me, say help."
   servant_desc_jala = "I am the servant of jala. I will sing songs to help you survive in battle and flee quickly. If you need help controlling me, say help."

   servant_response_heal_me = "~B~b%s heals you for %i health. We have %i remaining while we collect more."
   servant_response_heal_me_empty = "~B~k%s does not have enough health preserved to heal you."
   servant_response_heal_me_full = "~k%s whispers, ''I can't heal you right now. Something tells me you're going to be ok.''"
   servant_response_feed_me = "~B~b%s feeds you %i ration. We have %i remaining while we collect more."
   servant_response_feed_me_empty = "~B~k%s does not have enough rations preserved to feed you."
   servant_response_feed_me_full = "~k%s whispers, ''If I feed you any more food you'll become fat & slow and then I will eat you.''"
   servant_response_mystify_me = "~B~b%s feeds you %i mystical energy. We have %i remaining while we collect more."
   servant_response_mystify_me_empty = "~B~k%s does not have enough mystical energy preserved to channel."
   servant_response_mystify_me_full = "~k%s whispers, ''Maybe you should get one of your faren friends if you need more mana than this.''"
   
   servant_talk_max_heal_me = "~k%s whispers, ''Our health reserves are full again. If you need additional health, just ~rsay heal me~r.''~k"
   servant_talk_max_feed_me = "~k%s whispers, ''Our food reserves are full again. If you need additional vigor, just ~rsay feed me~r.''~k"
   servant_talk_max_mystify_me = "~k%s whispers, ''Our mana reserves are full again. If you need additional mana, just ~rsay mystify me~r.''~k"
   
   servant_tougher = "~B~IYour servant suddenly feels a little tougher!~B~I"

classvars:
   
   vrKocName = servant_koc_name_rsc
   vrName = servant_name_rsc
   vrIcon = servant_icon_rsc

   vrDead_icon = servant_dead_icon_rsc
   vrDead_name = servant_dead_name_rsc

   viTreasure_type = TID_NONE

   viSpeed = SPEED_WOLFPACKER
   viAttack_type = ATCK_WEAP_SLASH
   viAttack_spell = 0
   
   viDefault_behavior = AI_MOVE_FOLLOW_MASTER     | AI_FIGHT_MONSTERS \
                      | AI_FIGHT_SWITCHALOT       | AI_MOVE_REGROUP \
	                  | AI_MOVE_WALKTHROUGH_WALLS | AI_FIGHT_THROUGH_WALLS | AI_FIGHT_NEWBIESAFE
	   
   viWimpy = 2

   viLevel = 200
   viDifficulty = 10
   
   // Attack range of 192, or 3 row/col.
   viAttackRange = 192
   viVisionDistance = 5
   viCashmin = 1
   viCashmax = 2
   viAttributes = MOB_LISTEN | MOB_RECEIVE
   
   vrSound_hit = servant_sound_hit
   vrSound_miss = servant_sound_miss
   vrSound_aware = servant_sound_aware
   vrSound_death = servant_sound_death

   // Servants should be walk-through.
   viMoveOn_type = MOVEON_YES

properties:

   vrDesc = servant_desc_rsc

   piDrawEffectFlag = OF_BOUNCING
   viKarma = 0
   piAnimation = ANIM_NONE
   
   // Monsters mana
   piMana = 250
   piMax_mana = 250
   
   // Spells our servant can cast
   // [spellnum, mana, 1-100 random]
   plSpellBook = $

   // Monsters primary stats
   piAim = 50
   piAgility = 50
   
   // Spell object
   poSpell = $
   
   // Spell num
   piSpellNum = $
   
   // Spell school
   piSpellSchool = $
   
   piSpellPower = 0
   piSpellLevel = 1
   piPlayerDamage = 1
   piMonsterDamage = 1
   
   // They are neautral
   piReputationGroup = REP_NEUTRAL
   
   // Servant's bright aura - default is orange.
   poAura = LIGHT_ORANGE
   
   // Randomized lists
   plBuffs = $
   plCasts = $
   plTalk = $
   
   // Enchantments to remove after our servant departs
   plRemoveEnchants = $
   
   // Timers
   ptBuffs = $
   ptTalk = $
   ptImp = $
   ptTaunt = $
   ptServantResources = $
   
   // For use when we need to interact with NPCs from afar.
   plNPCLibrary = $
   plNPCNames = $
   
   // Servant's randomized name
   sServantName = $
   
   // Servant's commands
   plServantCommands = $

   // Servant Defaults
   pbAllowTalk = TRUE
   pbAllowBuff = TRUE
   pbAllowAttack = TRUE
   pbAllowCast = TRUE
   pbAllowTaunt = TRUE
   pbAllowFollow = TRUE
   pbAllowWalkThroughWalls = TRUE
   pbAllowAttackThroughWalls = TRUE
   
   // Servant PVP flags
   // TODO: Enable PVP defensive!
   //       MORE PVP SETTINGS COMING SOON!
   pbAllowAttackMurderers = FALSE
   
   // Until we have specifically colored monsters
   // We'll just use the DRAWFX system to color our servants.
   piDrawfx = DRAWFX_NONE
   
   // Show the name over our servant's head
   viObject_flags = OF_DISPLAY_NAME
   
   // Color of our name (should match the school)
   piNameColor = 0
   
   // Servants should be walk-through.
   pbNoMoveOn = FALSE
      
messages:
   
   // Send these values when you use the Create(&Servant, #...) function.
   Constructor(who = $, oSpell = $, iSpellNum = $, iSpellPower = $)
   {

      if who = $ OR NOT IsClass(who, &Player)
      {
         // Only a player can have a servant.
         propagate;
      }
	  
	  // Set our master
	  poMaster = who;
	  
	  // The spell object
	  poSpell = oSpell;
      
	  // The spell power from their summon cast.
	  piSpellPower = iSpellPower;
	  
     // The recreate heavy work - made this way so upon imping the spell, we can increase the piSpellPower and call this.
     Send(self,@RecalibrateServant, #iSpellNum=iSpellNum, #iSpellPower=iSpellPower);

	  // Start all of the servant's timers.
	  Send(self,@CreateServantTimers);
	 	  
      propagate;
   }
   
   Constructed()
   {   
	  Send(self,@PrepareServantNameAndDesc);
	  
	  propagate;
   }

   RecalibrateServant(iSpellNum=$, iSpellPower=0)
   {
      local iStats;

      Send(self,@SetSpellsLevel);

      // The spell we used to summon the servant
      piSpellNum = iSpellNum;

      // The spell school
      piSpellSchool = Send(poSpell,@GetSchool);

      // Set damage this servant can do to players & monsters based on spell power.
      // They are the same, but I made two versions in case we want to balance PVP and PVE.
      piPlayerDamage = Bound(iSpellPower / 4, 1, 25) * 100;
      piMonsterDamage = Bound(iSpellPower / 4, 1, 25) * 100;

      // Stats based on spell power.
      iStats = Bound(iSpellPower / 2, 1, 50);

      // Aim & Agility are the main stats for the servant.
      piAim = iStats;
      piAgility = iStats;

      // Prepare player's servant resources
      // feed me, heal me, mystify me
      Send(poMaster,@PrepareServantResources);

      // Set their name and description
      Send(self,@PrepareServantNameAndDesc);

      // Set the plSpellBook attack spells our monster can use
      Send(self,@SetServantSpellBook);

      return;
   }
   
   SetSpellsLevel()
   {
      if piSpellPower > 0 AND piSpellPower <= 20
	  {
	     piSpellLevel = 1;
	  }
      if piSpellPower > 20 AND piSpellPower <= 40
	  {
	     piSpellLevel = 2;
	  }
      if piSpellPower > 40 AND piSpellPower <= 60
	  {
	     piSpellLevel = 3;
	  }
      if piSpellPower > 60 AND piSpellPower <= 80
	  {
	     piSpellLevel = 4;
	  }
      if piSpellPower > 80 AND piSpellPower <= 98
	  {
	     piSpellLevel = 5;
	  }
      if piSpellPower >= 99
	  {
	     piSpellLevel = 6;
	  }
	  
	  return;
   }
   
   // TODO: We will need to get this turned on so the servant can protect the master.
   CanAttackPlayer(who = $)
   {
      Debug("ServantKODAttack",Send(self,@GetName),Send(who,@GetName));
	  
      return FALSE;
   }
   
   PrepareServantNameAndDesc()
   {
   	  if piSpellNum <> $ AND sServantName = $
	  {
        Send(self,@SetServantName);
	    Send(self,@SetServantDesc,#iSpellNum=piSpellNum);
	  }
	  
	  return;
   }
   
   MasterCheck()
   {
      if poMaster = $
	  {
	     Send(self,@Delete);
		 
		 return FALSE;
	  }
	  
	  return TRUE;
   }
   
   TweakBehavior(mob = $)
   {
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_FOLLOW_MASTER,#value=pbAllowFollow);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_MURDERERS,#value=pbAllowAttackMurderers);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_MONSTERS,#value=pbAllowAttack);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_SWITCHALOT,#value=TRUE);
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_REGROUP,#value=TRUE);
      Send(self,@SetBehaviorFlag,#flag=AI_MOVE_WALKTHROUGH_WALLS,#value=pbAllowWalkThroughWalls);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_THROUGH_WALLS,#value=pbAllowAttackThroughWalls);
      
	   // Disabled flags
	   Send(self,@SetBehaviorFlag,#flag=AI_MOVE_RANDOM,#value=FALSE);
      Send(self,@SetBehaviorFlag,#flag=AI_FIGHT_HYPERAGGRESSIVE,#value=FALSE);
	  
      return;
   }

   CreateServantTimers()
   {
      // Clear existing timers
	  Send(self,@ClearServantTimers);
	  
	  // Create some default data we need while working with timers
	  Send(self,@SetServantTalk);
	  
	  // Start the servant's timers
	  // TODO: Figure out why we're getting "Delete Timer / Cleanup Timer Failures all over our logs"...
      Send(self,@StartBuffTimer);
	  Send(self,@StartTalkTimer);
	  Send(self,@StartImpTimer);
	  Send(self,@StartTauntTimer);
	  Send(self,@StartServantResourcesTimer);
      
      return;
   }
   
   StartServantResourcesTimer()
   {
      ptServantResources = CreateTimer(self,@UpdateServantResources,1000);
	  
	  return;
   }
   
   StartBuffTimer()
   {
      ptBuffs = CreateTimer(self,@ServantBuffs,3000);
	  
	  return;
   }

   StartTalkTimer()
   {
      ptTalk = CreateTimer(self,@ServantTalk,120000);
	  
	  return;
   }

   StartImpTimer()
   {
      ptImp = CreateTimer(self,@ServantImps,1000);
	  
	  return;
   }
   
   StartTauntTimer()
   {
      ptTaunt = CreateTimer(self,@TauntEnemies,2000);
	  
	  return;
   }
   
   UpdateServantResources()
   {
      if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  Send(self,@StartServantResourcesTimer);

	  if Send(poMaster,@IncrementServantResourceInterval,#what=SERVANT_RESOURCE_HP)
	  {
	     Send(poMaster,@IncrementServantResource,#what=SERVANT_RESOURCE_HP,#amount=1);
	  }
	  
	  if Send(poMaster,@IncrementServantResourceInterval,#what=SERVANT_RESOURCE_MANA)
	  {
	     Send(poMaster,@IncrementServantResource,#what=SERVANT_RESOURCE_MANA,#amount=1);
	  }
	  
	  if Send(poMaster,@IncrementServantResourceInterval,#what=SERVANT_RESOURCE_VIGOR)
	  {
	     Send(poMaster,@IncrementServantResource,#what=SERVANT_RESOURCE_VIGOR,#amount=1);
	  }
	  
	  return;
   }

   ClearServantTimers()
   {
      if NOT Send(self,@MasterCheck)
      {
         return;
      }

      if ptBuffs <> $ AND IsTimer(ptBuffs) AND GetTimeRemaining(ptBuffs) > 0
      {
         DeleteTimer(ptBuffs);
         ptBuffs = $;
      }
      if ptTalk <> $ AND IsTimer(ptTalk) AND GetTimeRemaining(ptTalk) > 0
      {
         DeleteTimer(ptTalk);
         ptTalk = $;
      }
      if ptImp <> $ AND IsTimer(ptImp) AND GetTimeRemaining(ptImp) > 0
      {
         DeleteTimer(ptImp);
         ptImp = $;
      }
      if ptTaunt <> $ AND IsTimer(ptTaunt) AND GetTimeRemaining(ptTaunt) > 0
      {
         DeleteTimer(ptTaunt);
         ptTaunt = $;
      }

	  return;
   }
   
   ServantBuffs()
   {
      local iRandom, iSpellGroup, iSpellLevel, iSpellNum, iSpellRandom, iBuffPower, oSpell, iSpellRemove, lMinions, iChance, iHealth, iHealAmount, iMaxHealth, iMissing;
	  
	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  plRemoveEnchants = $;
   
	  Send(self,@StartBuffTimer);
	  
	  iHealth = Send(self,@GetHealth);
	  iMaxHealth = Send(self,@GetMaxHealth);
	  
	  // Check servant health and try to heal self.
	  if piSpellSchool = SS_SHALILLE
	  {
	     iChance = 40;
	  }
	  else
	  {
	     iChance = 35;
	  }
	  
	  if iHealth < iMaxHealth AND Random(1, 80) <= iChance
	  {
	     if piSpellSchool = SS_SHALILLE
	     {
		    iHealAmount = Random(35, 60);
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_heals_self_shalille,#parm1=iHealAmount);
		 }
		 else
		 {
		    iHealAmount = Random(25, 35);
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_heals_self_wand,#parm1=iHealAmount);
		 }
		 
		 Send(self,@HealHitPoint,#exact_amount=Bound(iHealAmount, 1, iMaxHealth - iHealth));
	  }
	  
	  if NOT pbAllowBuff
	  {
	     return;
	  }
	  
	  foreach iSpellGroup in plBuffs
	  {
	     iSpellLevel = Nth(iSpellGroup, 1);
		 
		 if piSpellLevel < iSpellLevel
		 {
		    continue;
		 }
		 
		 iSpellNum = Nth(iSpellGroup, 2);
		 iSpellRandom = Nth(iSpellGroup, 3);
		 iSpellRemove = Nth(iSpellGroup, 4);
		 
		 if iSpellRemove <> $ AND iSpellRemove = ENCHANT_REMOVE_SERVANT_DELETED
		 {
         if plRemoveEnchants = $
         {
            plRemoveEnchants = [];
         }
			
		    plRemoveEnchants = AppendListElem(iSpellNum, plRemoveEnchants);
		 }
		 
		 iRandom = Random(0, 100);
		 
		 if iSpellRandom >= iRandom
		 {
            iBuffPower = Send(poMaster, @GetSpellAbility, #spell_num=iSpellNum);
            
            if iBuffPower = 0
            {
               iBuffPower = Random(piSpellPower / 2, piSpellPower - 1) + 1;
            }
            
            oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
            
            if (oSpell <> $)
               AND (NOT Send(poMaster,@IsEnchanted,#what=oSpell))
               AND (NOT Send(poOwner,@IsEnchanted,#what=oSpell))
            {
               if iSpellNum = SID_MINOR_HEAL
                  OR iSpellNum = SID_MAJOR_HEAL
                  OR iSpellNum = SID_BREATH_OF_LIFE
                  OR iSpellNum = SID_HOSPICE
               {
                  // Only heal if the player needs mana.
                  iMissing = Send(poMaster, @GetMissingHealth);

                  if iMissing < 20
                  {
                     return;
                  }

                  Send(oSpell,@CastSpell,#who=self,#lTargets=[poMaster],#iSpellPower=iBuffPower);

                  return;                  
               }

               if iSpellNum = SID_MYSTIC_TOUCH
               {
                  // Only MT if the player needs mana.
                  iMissing = Send(poMaster, @GetMissingMana);

                  if iMissing < 10
                  {
                     return;
                  }

                  iMissing = Send(poMaster, @GetMana);

                  if iMissing > 75
                  {
                     // We cannot mystic touch past this point.
                     return;
                  }

                  Send(oSpell,@CastSpell,#who=self,#lTargets=[poMaster],#iSpellPower=iBuffPower);
                  
                  // Restore servant's mana so mystic touch is less annoying.
                  Send(self,@NewMaxMana,#amount=200);

                  return;                  
               }

               if iSpellNum = SID_RELAY
               {
                  // Only relay if the player needs vigor
                  iMissing = Send(poMaster, @GetVigor);

                  if iMissing >= 135
                  {
                     // We cannot relay past this point.
                     return;
                  }

                  Send(oSpell,@CastSpell,#who=self,#lTargets=[poMaster],#iSpellPower=iBuffPower);

                  return;
               }

               // Prevent servants from having too many reflections/minions.
               lMinions = Send(self,@GetControlledMinions);

               if iSpellNum = SID_REFLECTION AND lMinions <> $ AND Length(lMinions) >= MAX_SERVANT_MINIONS
               {
                  return;
               }
               else
               {
                  if iSpellNum = SID_REFLECTION
                  {
                     Send(oSpell,@CastSpell,#who=self,#lTargets=[self],#iSpellPower=iBuffPower);

                     return;
                  }
               }
            
               Send(oSpell,@CastSpell,#who=poMaster,#lTargets=[poMaster],#iSpellPower=iBuffPower);
            }			   
         }
	  }
	  
      return;
   }
   
   RemoveImportantServantEnchants()
   {
      local iSpellNum, oSpell, lPlayers, lPlayer;
	  
	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
	  
	  // All radius enchantments will go
	  Send(poMaster,@RemoveAllRadiusEnchantments,#report=TRUE);
	  	  
      if plRemoveEnchants = $
	  {
	     return;
	  }
	  
	  foreach iSpellNum in plRemoveEnchants
	  {
	     oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);

		 if oSpell <> $
		    AND (Send(poMaster,@IsEnchanted,#what=oSpell)
		         OR Send(poOwner,@IsEnchanted,#what=oSpell))
		 {
			if Send(poMaster,@IsEnchanted,#what=oSpell)
			{
		       Send(poMaster,@RemoveEnchantment,#what=oSpell);
			}
			
			if Send(poOwner,@IsEnchanted,#what=oSpell)
			{
		       Send(poOwner,@RemoveEnchantment,#what=oSpell);
			}
		 }			   
	  }
	  
	  plRemoveEnchants = $;
	  
	  // Reset my icons and room enchants in case someone else has them up
 	  Send(poOwner,@ResetMyRoomEnchantments,#who=poMaster);
	  
	  return;
   }
      
   // Needed for relay
   AddExertion()
   {
      return;
   }
   
   // Needed for relay
   GetVigor()
   {
      return 200;
   }
   
   ServantTalk()
   {
      local iRandomPart, iRandomPiece, chosen_resource, tmp_rsc;

      if NOT Send(self,@MasterCheck)
      {
         return;
      }

      Send(self,@StartTalkTimer);

      if NOT pbAllowTalk
      {
         return;
      }

	  iRandomPart = Random(0, Length(plTalk));
	  iRandomPiece = Random(0, Length(Nth(plTalk, iRandomPart)));
	  chosen_resource = Nth(Nth(plTalk, iRandomPart), iRandomPiece);
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc,#parm1=chosen_resource);
	  	  
      return;
   }

   ServantImps()
   {
      local iRandom, iInitialChance, increase_chance, iLastAttack, iRandomCap;

      iRandomCap = 500;

      if NOT Send(self,@MasterCheck)
      {
         return;
      }

      Send(self,@StartImpTimer);
	   
      iLastAttack = Send(poMaster, @SinceLastAttack);

      if iLastAttack <= 10
      {
         iRandomCap = 300;
      }

      if iRandomCap >= 500
      {
         // Harder to imp while sitting still.
         iInitialChance = Send(poSpell,@GetInitialChance,#who=poMaster);
         iRandom = random(1,iRandomCap);
      
         if iRandom > iInitialChance
         {
            return;
         }
      }
	  	  
      iRandom = random(0,iRandomCap);

      if iRandom < 5
      {
         Send(poMaster,@ChangeSpellAbility,#spell_num=piSpellNum,#amount=1,#report=TRUE);

         // Since we advanced, reset our school cast improvement bonus.
         Send(poMaster,@ResetSchoolCast,#school=piSpellSchool);

         // The spell power from their summon cast.
         piSpellPower = Bound(piSpellPower + 1, 1, 99);
         
         // The recreate heavy work - made this way so upon imping the spell, we can increase the piSpellPower and call this.
         Send(self,@RecalibrateServant, #iSpellNum=piSpellNum, #iSpellPower=piSpellPower);

         if piSpellPower < 99
         {
            Post(poMaster,@MsgSendUser,#message_rsc=servant_tougher);
         }
      }
	  
      return;
   }
   
   SetServantTalk()
   {
      plTalk = [
	     [servant_rant_a, servant_rant_b, servant_rant_c, servant_rant_d, servant_rant_e, servant_rant_f, servant_rant_g,
	     servant_rant_h, servant_rant_i, servant_rant_j, servant_rant_k, servant_rant_l, servant_rant_m, servant_rant_n,
	     servant_rant_o, servant_rant_p, servant_rant_q, servant_rant_r, servant_rant_s, servant_rant_t, servant_rant_u,
	     servant_rant_v, servant_rant_w, servant_rant_x, servant_rant_y, servant_rant_z],
	     [servant_rant_aa, servant_rant_ab, servant_rant_ac, servant_rant_ad, servant_rant_ae, servant_rant_af, servant_rant_ag,
	     servant_rant_ah, servant_rant_ai, servant_rant_aj, servant_rant_ak, servant_rant_al, servant_rant_am, servant_rant_an,
	     servant_rant_ao, servant_rant_ap, servant_rant_aq, servant_rant_ar, servant_rant_as, servant_rant_at, servant_rant_au,
	     servant_rant_av, servant_rant_aw, servant_rant_ax, servant_rant_ay, servant_rant_az],
	     [servant_rant_aaa, servant_rant_aab, servant_rant_aac, servant_rant_aad, servant_rant_aae, servant_rant_aaf, servant_rant_aag,
	     servant_rant_aah, servant_rant_aai, servant_rant_aaj, servant_rant_aak, servant_rant_aal, servant_rant_aam, servant_rant_aan,
	     servant_rant_aao, servant_rant_aap, servant_rant_aaq, servant_rant_aar, servant_rant_aas, servant_rant_aat, servant_rant_aau,
	     servant_rant_aav, servant_rant_aaw, servant_rant_aax, servant_rant_aay, servant_rant_aaz],
	     [servant_rant_aaaa, servant_rant_aaab, servant_rant_aaac, servant_rant_aaad, servant_rant_aaae, servant_rant_aaaf, servant_rant_aaag,
	     servant_rant_aaah, servant_rant_aaai, servant_rant_aaaj, servant_rant_aaak, servant_rant_aaal, servant_rant_aaam, servant_rant_aaan,
	     servant_rant_aaao, servant_rant_aaap, servant_rant_aaaq, servant_rant_aaar, servant_rant_aaas, servant_rant_aaat, servant_rant_aaau,
	     servant_rant_aaav, servant_rant_aaaw, servant_rant_aaax, servant_rant_aaay, servant_rant_aaaz]
	  ];
	  
	  return;
   }
   
   SetFarenSpells()
   {
      plCasts = [
	     [4, SID_BLAST_OF_FIRE, 50],
	     [4, SID_FIREBALL, 30],
	     [4, SID_EXPLOSIVE_FROST, 15],
	     [5, SID_LIGHTNING_BOLT, 20]
	  ];
	  
      plBuffs = [
	     [1, SID_LIGHT, 100, $],
	     [1, SID_MYSTIC_TOUCH, 60, $],
	     [2, SID_RESIST_COLD, 100, $],
	     [2, SID_RESIST_FIRE, 100, $],
	     [3, SID_RESIST_SHOCK, 100, $]
	  ];

      return;
   }

   SetRiijaSpells()
   {
      plCasts = [
         [2, SID_FORGET, 2],
         [3, SID_ILLUSIONARY_WOUNDS, 50],
         [3, SID_VERTIGO, 10],
         [3, SID_DEMENT, 5],
         [4, SID_APPARITION, 20],
         [5, SID_EVIL_TWIN, 20]
	  ];

      plBuffs = [
         [1, SID_SHADOW_FORM, 100, $],
         [3, SID_REFLECTION, 100, $]
	  ];
	  
      return;
   }

   SetKranSpells()
   {
      // Kraanan has some offensive spells, but they might mess with the master.
	  // Such as, dispel illusion if the master is running around as a shadowbeast pking.
	  // Mana bomb might also be an issue.
	  // Anti-magic aura, another huge problem.
	  
      plCasts = $;

      plBuffs = [
         [2, SID_BLESS, 100, $],
         [2, SID_HASTE, 100, $],
         [2, SID_RELAY, 60, $],
         [2, SID_SUPER_STRENGTH, 100, $],
         [3, SID_MARTYRS_BATTLEGROUND, 100, $],
         [3, SID_NIGHT_VISION, 100, $],
         [3, SID_MAGIC_SHIELD, 100, $],
         [3, SID_DETECT_INVISIBLE, 70, $],
         [3, SID_FREE_ACTION, 70, $],
         [4, SID_DEFLECT, 70, $],
         [4, SID_EAGLE_EYES, 70, $],
         [5, SID_KILLING_FIELDS, 100, $],
         [5, SID_ARMOR_OF_GORT, 60, $],
         [5, SID_RESIST_MAGIC, 30, $]
	  ];
	  
      return;
   }

   SetShalSpells()
   {
      plCasts = [
	     [4, SID_DAZZLE, 5],
	     [4, SID_MARK_OF_DISHONOR, 25],
	     [4, SID_HOLY_BLAZE, 50],
	     [5, SID_PURGE, 5]
	  ];
     
	  plBuffs = [
	     [1, SID_MINOR_HEAL, 5, $],
	     [1, SID_DETECT_EVIL, 100, $],
	     [1, SID_REMOVE_CURSE, 100, $],
	     [2, SID_CURE_POISON, 100, $],
	     [2, SID_RESIST_ACID, 100, $],
	     [3, SID_CURE_DISEASE, 100, $],
	     [3, SID_HOLY_RESOLVE, 100, $],
        [3, SID_BREATH_OF_LIFE, 5, $],
	     [3, SID_HOSPICE, 5, $],
	     [4, SID_FORCES_OF_LIGHT, 90, $],
	     [4, SID_PURIFY, 3, $],
	     [5, SID_MAJOR_HEAL, 1, $]
	  ];

      return;
   }

   SetQorSpells()
   {
      plCasts = [
	     [3, SID_ENFEEBLE, 60],
	     [3, SID_VAMPIRIC_DRAIN, 50],
	     [3, SID_POISON_FOG, 5],
		  [4, SID_SPLASH_OF_ACID, 50],
	     [4, SID_HOLD, 5],
	     [5, SID_BLIND, 5]
	  ];

      plBuffs = [
	     [1, SID_CLOAK, 100, $],
	     [1, SID_DARKNESS, 100, $],
	     [1, SID_DETECT_GOOD, 100, $],
	     [1, SID_UNHOLY_RESOLVE, 100, $],
	     [5, SID_DEATH_LINK, 100, $],
	     [5, SID_INVISIBILITY, 50, $]
	  ];
	  
      return;
   }

   SetJalaSpells()
   {
      // Jala has no offensive spells we want to use...
	  plCasts = $;
	  
      plBuffs = [
	     [1, SID_INVIGORATE, 100, $],
	     [3, SID_WOLFPACK, 100, $],
	     [3, SID_RESTORATE, 100, $],
	     [5, SID_REJUVENATE, 100, $]
	  ];

      return;
   }
   
   // We'll use the built in spell casting system the game already has for monsters.
   // If it sucks, we'll make some improvements.
   // This all goes back to plSpellBook.
   SetServantSpellBook()
   {
      local iSpellGroup, oSpell;
	  
      if plCasts = $
	  {
         return;
	  }
	  
	  plSpellBook = $;
	  
	  foreach iSpellGroup in plCasts
	  {
	     if piSpellLevel >= Nth(iSpellGroup, 1)
		 {
	        if plSpellBook = $
			{
			   plSpellBook = [];
			}
			
			// Nth(2) = Spell Num, 1 = Mana, Nth(3) = Random 1-100 chance
			// See plCasts.
			oSpell = Send(SYS,@FindSpellByNum,#num=Nth(iSpellGroup, 2));
	        plSpellBook = AppendListElem([Nth(iSpellGroup, 2), 1, Nth(iSpellGroup, 3)], plSpellBook);
		 }
	  }
	  
	  return;
   }
   
   GetPlayerDamage()
   {
      return piPlayerDamage;
   }
   
   GetMonsterDamage()
   {
      return piMonsterDamage;
   }

   // Can't attack players.
   // YET.
   // TODO: Allow attacking players if a player attacks the servant owner.
   AllowBattlerAttack(victim=$)
   {
      // Must be in a room to attack, must have target.
      if (poOwner = $
         OR victim = $)
      {
         return FALSE;
      }

      if (IsClass(victim,&Player) OR IsClass(victim,&User)) AND NOT Send(self,@CanAttackPlayer,#who=victim)
      {
	     // Servant is not allowed to attack this player.
         return FALSE;
      }
	  
	  // Master may have turned off attacking through commands.
	  if NOT pbAllowAttack
	  {
	     return FALSE;
	  }

      propagate;
   }
   
   MonsterAttack(what = $)
   {
      // add in any attack animation calls
      Send(self,@DoSlash);
      Send(poOwner,@SomethingShot,#who=self,#target=what,#projectile=self,
            #flags=PROJ_FLAG_LIGHT_SOURCE);

      return;
   }

   DoSlash()
   {
      piAnimation = ANIM_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = ANIM_NONE;

      return;
   }

   SendLookAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,100,2,3,2,4);

      return;
   }

   SendMoveAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,100,2,3,2,4);

      return;
   }

   SendAnimation()
   {
      if piAnimation = ANIM_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE,4,100,2,5,2,8,2,1);

         return;
      }

      AddPacket(1,ANIMATE_CYCLE,4,100,2,1,2,2);

      return;
   }

   GetProjectileIcon()
   {
      return servant_fireball;
   }

   GetProjectileSpeed()
   {
      return 7;
   }

   SendProjectileAnimation()
   {
      AddPacket(1,ANIMATE_CYCLE,4,50,2,1,2,4);

      return;
   }

   GetProjectileLightFlags()
   {
      // General lighting information.
      return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
   }

   GetProjectileLightIntensity()
   {
      // Fairly small light radius for projectile.  Out of 255 levels.
      return 255;
   }

   GetProjectileLightColor()
   {
      // Color is based on mushroom color fed
      return LIGHT_ORANGE;
   }

   SendLightingInformation()
   {
      AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
      // Intensity (out of 255)
      AddPacket(1,13);
      // Color
      AddPacket(2,poAura);

      return;
   }

   CanMorphTo()
   {
      return FALSE;
   }


   Killed(what=$)
   {
      if (IsClass(what, &Servant) AND Send(poMaster,@GetServant) = what)
	     OR (IsClass(what, &Player) AND poMaster = what)
	  {
	     Send(self,@GracefullyDeleteServant);
	  }
	  
	  propagate;
   }
   
   GracefullyDeleteServant()
   {
      Send(self,@RemoveAllMinions);

   	  Send(self,@ClearServantTimers);

      if Send(self,@MasterCheck) 
	  {
         Send(self,@RemoveImportantServantEnchants);
	     Send(poMaster,@RemoveControlledMinion,#what=self);
		 Send(poMaster,@SetServant,#oServant=$);
	  }
	  
	  poMaster = $;
	  
	  Send(self,@Delete);
	  
	  return;
   }

   Delete()
   {
      if poMaster <> $
	  {
	     Send(self,@GracefullyDeleteServant);
	  }
	  	  
      propagate;
   }

   CanAcceptOffer()
   {
      return TRUE;
   }

   CreateTreasure()
   {
      return;
   }
   
   SomethingLeft(what=$)
   {
      local oRoom;

      if NOT Send(self,@MasterCheck)
      {
         return;
      }

      if (what = poMaster)
      {
         oRoom = Send(poMaster,@GetOwner);

         if oRoom = $ OR IsClass(oRoom,&UnderWorld)
         {
            Send(self,@Delete);

            return;
         }
         else
         {
            Post(self,@GotoMaster);
         }
      }

      propagate;
   }

   GotoMaster()
   {
      local oRoom;

      if NOT Send(self,@MasterCheck)
      {
         return;
      }
	  
      oRoom = Send(poMaster,@GetOwner);
	  
      if oRoom = $ OR poOwner = $
      {
         return;
      }
	  
      Send(self,@EnterStateWait);
      Send(self,@TweakBehavior);

	  Send(SYS,@UtilGoNearSquare,#what=self,#where=oRoom,
		    #new_row=Send(poMaster,@GetRow),
		    #new_col=Send(poMaster,@GetCol));

      return;
   }
   
   SomethingMoved(what=$,new_row=$,new_col=$)
   {
      local iMasterDistance, iServantState, iActionDistance;
	  
      if poOwner <> $ AND Send(self,@MasterCheck)
      {
         Send(poOwner,@DeleteWallsAroundBattler,#who=self);
      }

      if what = $ OR what = self 
	  {
	     propagate;
	  }
	  
	  if Send(self,@MasterCheck) AND what = poMaster
	  {
	    iMasterDistance = Send(self,@SquaredDistanceTo,#what=poMaster);
		 iServantState = Send(self,@GetState);
		 
		 switch (iServantState)
		 {
		    case STATE_ATTACK:
			   iActionDistance = RETREAT_DISTANCE;
			break;
			case STATE_CHASE:
			   iActionDistance = RETREAT_DISTANCE;
			break; 
			case STATE_MOVE: 
			   iActionDistance = RETREAT_DISTANCE;
			break;
			case STATE_LIMBO:
			   iActionDistance = IDLE_DISTANCE;
			break;
			case STATE_WAIT:
			   iActionDistance = IDLE_DISTANCE;
			break;
		 }
		 
		 if iMasterDistance > iActionDistance
		 {
		    Send(self,@EnterStateLimbo);
		    Send(self,@GotoMaster);
		 }
	  }
	  
      propagate;
   }
   
   
   // Whenever someone says something, our servant is listening in case it's something we can help with.
   // We need to perform several checks on what the user said.
   // They might be asking for things like:
   //    mace fighting    or    blind    or     punch
   // These can return the "how much further" response the normal NPC sends.
   // Other commands could be:
   //    shut up (makes them stop talking)
   //    stop buffing (makes them stop buffing)
   //    stop casting (makes them stop casting)
   //    stop attacking (makes them docile and useless)
   ServantHandleSay(what = $,type = $,string = $)
   {
      local bResponded;

      bResponded = FALSE;

      if IsClass(what,&User) AND poMaster = what
      {
         // Check for basic servant commands, they're the easiest to figure out first.
         bResponded = Send(self,@GetSaidServantCommand,#said_string=string);

         if NOT bResponded
         {
            // Check for player advancement (skills/spells).
            bResponded = Send(self,@GetSaidProgress,#said_string=string);
         }
      }

      // Clear out the NPC library - it may be causing errors if we leave the data.
      plNPCLibrary = $;

      return bResponded;
   }
      
   GetSaidProgress(said_string="derpaderp")
   {
      local lNPCLibraryItem, oAbility, oAbilityName, iAbilityNum, oNPC, iLearnedAlready, bCanLearn, oSpell, oSkill;
	  
      // When we finally determine the NPC, we should check if the NPC is already in the room with us.
	  // We don't want duplicate messages appearing.
	  // Let's first see if what they said is in our ability library (spells & skills).
	  
	  Send(self,@PrepareNPCList);
	  
	  if plNPCLibrary <> $
	  {
	     // Iterate the NPC objects and see if they teach what we said...
		 foreach lNPCLibraryItem in plNPCLibrary
		 {
		    oNPC = Nth(lNPCLibraryItem, 1);
			
			if oNPC = $
			{
			   continue;
			}
			
		    foreach oAbility in Nth(lNPCLibraryItem, 2)
			{
			   iLearnedAlready = FALSE;
			   oAbilityName = $;
			   
			   if oAbility <> $ AND IsClass(oAbility, &Spell)
			   {
			      // Spell name
			      oAbilityName = Send(oAbility,@GetName);
				  iAbilityNum = Send(oAbility,@GetSpellNum);
			   }

			   if oAbility <> $ AND IsClass(oAbility, &Skill)
			   {
			      // Skill name
			      oAbilityName = Send(oAbility,@GetName);
				  iAbilityNum = Send(oAbility,@GetSkillNum);
			   }
			   
			   if oAbilityName <> $
			   {
			      // Check if this matches what we said...
				  if NOT StringEqual(oAbilityName, said_string)
				  {
				     continue;
				  }
				  
			      // Check if we know this spell or skill already.
				  if IsClass(oAbility, &Spell)
				  {
				     iLearnedAlready = Send(poMaster, @GetSpellAbility, #spell_num=Send(oAbility,@GetSpellNum));
				  }
				  
				  if IsClass(oAbility, &Skill)
				  {
				     iLearnedAlready = Send(poMaster, @GetSkillAbility, #Skill_num=Send(oAbility,@GetSkillNum));
				  }
				  
				  if iLearnedAlready > 0
				  {
				     // We have already learned this.
					 // Tell the master!
					 Post(poMaster,@MsgSendUser,#message_rsc=servant_already_learned,#parm1=oAbilityName);
					 
					 return TRUE;
				  }
				  
				  // Let's reach out to this NPC and see if we can learn it...
				  Send(oNPC, @CanDoTeach, #who=poMaster, #sid=iAbilityNum, 
				      #bSkill=IsClass(oAbility, &Skill), #oRequester=self);
              return TRUE;
			   }
			}
		 }
	  }
	  
	  return FALSE;
   }
   
   PrepareNPCList()
   {
      local sNPCName, oNPC, lNPCForSale;
	  
      if plNPCNames = $
	  {
	     plNPCNames = [
		    npc_a, npc_b, npc_c, npc_d, npc_e, npc_f, npc_g, npc_h, npc_i, npc_j, npc_k, npc_l, npc_m, npc_n,
		    npc_o, npc_p, npc_q, npc_r, npc_s, npc_t, npc_u, npc_v, npc_w, npc_x, npc_y, npc_z, 
		    npc_aa, npc_ab, npc_ac, npc_ad, npc_ae, npc_af, npc_ag
		 ];
	  }
	  
      if plNPCLibrary = $
	  {
		 plNPCLibrary = [];
		 
		 foreach sNPCName in plNPCNames
		 {
            oNPC = Send(SYS,@FindNPCByString,#string=sNPCName);
						
            if oNPC <> $
            {
			   if plNPCLibrary = $
			   {
			      plNPCLibrary = [];
			   }
			   
			   lNPCForSale = Send(oNPC, @GetForSale, #report=FALSE, #conditional=FALSE, #items=FALSE);
			   
			   if lNPCForSale <> $
			   {
                  plNPCLibrary = AppendListElem([oNPC, lNPCForSale], plNPCLibrary);
			   }
            }
         }		 
	  }
	  
	  return;
   }
   
   SetServantDesc(iSpellNum=$)
   {
      if iSpellNum = $
	  {
	     return;
	  }
      
      switch(iSpellNum) {
		case SID_RIIJA_SERVANT:
		   vrDesc = servant_desc_riija;
		break;
		case SID_FAREN_SERVANT:
		   vrDesc = servant_desc_faren;
		break;
		case SID_KRAN_SERVANT:
		   vrDesc = servant_desc_kran;
		break;
		case SID_SHAL_SERVANT:
		   vrDesc = servant_desc_shal;
		break;
		case SID_QOR_SERVANT:
		   vrDesc = servant_desc_qor;
		break;
		case SID_JALA_SERVANT:   
		   vrDesc = servant_desc_jala;
		break;
	  }
	  
      return;
   }

   SetServantName()
   {
      local lServantNames;
	  
	  lServantNames = [
	     servant_name_1, servant_name_2, servant_name_3, servant_name_4, servant_name_5,
	     servant_name_6, servant_name_7, servant_name_8, servant_name_9, servant_name_10,
	     servant_name_11, servant_name_12, servant_name_13, servant_name_14, servant_name_15,
	     servant_name_16, servant_name_17, servant_name_18, servant_name_19, servant_name_20,
	     servant_name_21, servant_name_22, servant_name_23, servant_name_24, servant_name_25,
	     servant_name_26, servant_name_27, servant_name_28, servant_name_29, servant_name_30,
	     servant_name_31, servant_name_32, servant_name_33, servant_name_34, servant_name_35,
	     servant_name_36, servant_name_37, servant_name_38, servant_name_39, servant_name_40
	  ];
	  
	  sServantName = Nth(lServantNames, Random(1, Length(lServantNames)));
	  
	  return;
   }
   
   GetName()
   {
      if sServantName = $
	  {
	     Send(self,@SetServantName);
	  }
	  
      return sServantName;
   }
   
   GetTrueName()
   {
      return Send(self,@GetName);
   }
   
   GetApparentName()
   {
      return Send(self,@GetName);
   }
   
   ShowDesc(iHitPoint_Percent = $)
   "Shows what the servant is capable of (basically the level of magic)."
   {
      local iHit_Percent, rMonster_condition;

      if iHitPoint_Percent = $
      {
         iHit_Percent = piHit_points / piMax_hit_points;
      }
      else
      {
         iHit_Percent = iHitPoint_Percent;
      }

      if iHit_Percent > 80
      {
         if piBehavior & AI_NPC
         {
            AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,monster_nothing);
         }
         else
         {
		    if piSpellLevel = 1
			{
               AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,servant_desc_level_one,
                         4,Send(poSpell,@GetSchoolStr));
			}
		    if piSpellLevel = 2
			{
               AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,servant_desc_level_two,
                         4,Send(poSpell,@GetSchoolStr));
			}
		    if piSpellLevel = 3
			{
               AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,servant_desc_level_three,
                         4,Send(poSpell,@GetSchoolStr));
			}
		    if piSpellLevel = 4
			{
               AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,servant_desc_level_four,
                         4,Send(poSpell,@GetSchoolStr));
			}
		    if piSpellLevel = 5
			{
               AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,servant_desc_level_five,
                         4,Send(poSpell,@GetSchoolStr));
			}
		    if piSpellLevel = 6
			{
               AddPacket(4,vrCondition_healthy, 4,vrDesc, 4,servant_desc_level_six,
                         4,Send(poSpell,@GetSchoolStr));
			}
         }

         return;
      }
      else if iHit_Percent > 60
      {
         rMonster_condition = vrCondition_good;
      }
      else if iHit_Percent > 40
      {
         rMonster_condition = vrCondition_fair;
      }
      else if iHit_Percent > 20
      {
         rMonster_condition = vrCondition_poor;
      }
      else
      {
         rMonster_condition = vrCondition_bad;
      }

      if piBehavior & AI_NPC
      {
         AddPacket(4,rMonster_Condition, 4,vrDesc, 4,monster_nothing,
                   4,Send(self,@GetCapDef), 4,Send(self,@GetName));
      }
      else
      {
	     if piSpellLevel = 1
		 {
            AddPacket(4,rMonster_Condition, 4,vrDesc, 4,servant_desc_level_one,
                      4,Send(poSpell,@GetSchoolStr), 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName));
         }
	     if piSpellLevel = 2
		 {
            AddPacket(4,rMonster_Condition, 4,vrDesc, 4,servant_desc_level_two,
                      4,Send(poSpell,@GetSchoolStr), 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName));
         }
	     if piSpellLevel = 3
		 {
            AddPacket(4,rMonster_Condition, 4,vrDesc, 4,servant_desc_level_three,
                      4,Send(poSpell,@GetSchoolStr), 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName));
         }
	     if piSpellLevel = 4
		 {
            AddPacket(4,rMonster_Condition, 4,vrDesc, 4,servant_desc_level_four,
                      4,Send(poSpell,@GetSchoolStr), 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName));
         }
	     if piSpellLevel = 5
		 {
            AddPacket(4,rMonster_Condition, 4,vrDesc, 4,servant_desc_level_five,
                      4,Send(poSpell,@GetSchoolStr), 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName));
         }
	     if piSpellLevel = 6
		 {
            AddPacket(4,rMonster_Condition, 4,vrDesc, 4,servant_desc_level_six,
                      4,Send(poSpell,@GetSchoolStr), 4,Send(self,@GetCapDef),
                      4,Send(self,@GetName));
         }
	  }

      return;
   }
   
   // Adds "the or a <servant name>" to things the servant shows in chat.
   GetDef()
   {
      return servant_empty_rsc;
   }
   
   // Adds "The or A <servant name>" to things the servant shows in chat.
   GetCapDef()
   {
      return servant_empty_rsc;
   }

   TauntEnemies()
   {
      ptTaunt = $;
	  
   	  if NOT Send(self,@MasterCheck)
	  {
	     return;
	  }
   
      ptTaunt = CreateTimer(self,@TauntEnemies,1000);
	  
	  if NOT pbAllowTaunt
	  {
	     return;
	  }
	  
	  if poTarget <> $ AND IsClass(poTarget,&Monster)
	  {
	     // Tells the target to switch to the servant
		 // with a massive amount of hate.
		 // Only works if you enter combat with the monster.
         Send(poTarget,@TargetSwitch,#what=self,#iHatred=10000);
	  }
	  
	  return;
   }
   
   ClearTauntTimer()
   {
      if ptTaunt <> $ AND IsTimer(ptTaunt)
      {
         DeleteTimer(ptTaunt);
      }
	  
	  return;
   }

   GetSaidServantCommand(said_string="derpaderp")
   {
      local bIsCommand, iPlayerMissingHealth, iPlayerMissingMana, iPlayerMissingVigor, iPulledAmount, bAcknowledge, bDeleteServant;
	  
	  bIsCommand = FALSE;
     bAcknowledge = FALSE;
	  
	  // Show the help command output to our master.
      if StringEqual(said_string, servant_command_help)
      {
	     Post(poMaster,@MsgSendUser,#message_rsc=servant_response_help);
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
	  
	  
      if StringEqual(said_string, servant_command_quiet)
      {
	     if pbAllowTalk
		 {
		    pbAllowTalk = FALSE;
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }	  
      if StringEqual(said_string, servant_command_loud)
      {
	     if NOT pbAllowTalk
		 {
		    pbAllowTalk = TRUE;
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_nodes)
      {
         Send(Send(SYS,@GetLibrary), @PlayerManaNodeList, #mob=self, #person=poMaster);
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_no_buffs)
      {
	     if pbAllowBuff
		 {
		    pbAllowBuff = FALSE;
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_do_buffs)
      {
	     if NOT pbAllowBuff
		 {
		    pbAllowBuff = TRUE;
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_stop_taunting)
      {
	     if pbAllowTaunt
		 {
		    pbAllowTaunt = FALSE;
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_taunt)
      {
	     if NOT pbAllowTaunt
		 {
		    pbAllowTaunt = TRUE;
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_stop_attacking)
      {
	     if pbAllowAttack
		 {
		    pbAllowAttack = FALSE;
			pbAllowCast = FALSE;
			plSpellBook = $;
            Send(self,@TweakBehavior);
			Send(self,@SetState,#bit=STATE_WAIT);
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_attack)
      {
	     if NOT pbAllowAttack
		 {
		    pbAllowAttack = TRUE;
			pbAllowCast = TRUE;
			Send(self,@SetServantSpellBook);
            Send(self,@TweakBehavior);
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_stop_casting)
      {
	     if pbAllowCast
		 {
		    pbAllowCast = FALSE;
			plSpellBook = $;
            Send(self,@TweakBehavior);
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_cast)
      {
	     if NOT pbAllowCast
		 {
		    pbAllowCast = TRUE;
			Send(self,@SetServantSpellBook);
            Send(self,@TweakBehavior);
		 }
		 
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }
      if StringEqual(said_string, servant_command_heal_me)
      {
	     iPlayerMissingHealth = Send(poMaster, @GetMissingHealth);
		 
		 if iPlayerMissingHealth <> 0
		 {
		    iPulledAmount = Send(poMaster, @DecrementServantResource,#what=SERVANT_RESOURCE_HP,#amount=iPlayerMissingHealth);

		    if iPulledAmount <= 0
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_heal_me_empty,
			      #parm1=Send(self,@GetName));
		    }
		    else
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_heal_me,
			      #parm1=Send(self,@GetName),#parm2=iPulledAmount,
			      #parm3=Send(poMaster, @GetServantResourceAmount, #what=SERVANT_RESOURCE_HP));
				  
			   Send(poMaster,@GainHealth,#amount=iPulledAmount,#precision=FALSE);
		    }
		 }
		 else
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_response_heal_me_full,
			   #parm1=Send(self,@GetName));
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_feed_me)
      {
	     iPlayerMissingVigor = Send(poMaster, @GetMissingVigor);

		 if iPlayerMissingVigor <> 0
		 {
		    iPulledAmount = Send(poMaster, @DecrementServantResource,#what=SERVANT_RESOURCE_VIGOR,#amount=iPlayerMissingVigor);

		    if iPulledAmount <= 0
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_feed_me_empty,
			      #parm1=Send(self,@GetName));
		    }
		    else
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_feed_me,
			      #parm1=Send(self,@GetName),#parm2=iPulledAmount,
			      #parm3=Send(poMaster, @GetServantResourceAmount, #what=SERVANT_RESOURCE_VIGOR));
				  
			   Send(poMaster,@GainVigor,#amount=iPulledAmount);
		    }
		 }
		 else
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_response_feed_me_full,
			   #parm1=Send(self,@GetName));
		 }

	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_mystify_me)
      {
	     iPlayerMissingMana = Send(poMaster, @GetMissingMana);

		 if iPlayerMissingMana <> 0
		 {
		    iPulledAmount = Send(poMaster, @DecrementServantResource,#what=SERVANT_RESOURCE_MANA,#amount=iPlayerMissingMana);

		    if iPulledAmount <= 0
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mystify_me_empty,
			      #parm1=Send(self,@GetName));
		    }
		    else
		    {
		       Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mystify_me,
			      #parm1=Send(self,@GetName),#parm2=iPulledAmount,
			      #parm3=Send(poMaster, @GetServantResourceAmount, #what=SERVANT_RESOURCE_MANA));
				  
			   Send(poMaster,@GainMana,#amount=iPulledAmount);
		    }
		 }
		 else
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mystify_me_full,
			   #parm1=Send(self,@GetName));
		 }
		 
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_go_away)
      {
	     bDeleteServant = TRUE;
	     bIsCommand = TRUE;
        bAcknowledge = TRUE;
      }	  
      if StringEqual(said_string, servant_command_identify)
      {
	     Send(self,@IdentifyMasterHolding);
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_reveal)
      {
	     Send(self,@RevealMasterHolding);
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_mend)
      {
	     Send(self,@MendMasterHolding);
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_bait)
      {
	     Send(self,@BaitMonsters);
	     bIsCommand = TRUE;
      }
      if StringEqual(said_string, servant_command_disguise)
      {
	     Send(self,@DisguiseMaster);
	     bIsCommand = TRUE;
      }

      if bAcknowledge
      {
         // Generic servant response.
		   Post(poMaster,@MsgSendUser,#message_rsc=servant_acknowledge);
      }

      if bDeleteServant
      {
         // We delete afterwards so the poMaster is still set.
         Send(self,@GracefullyDeleteServant);
      }
      
	  return bIsCommand;
   }

   DMCanArmageddon()
   {
      return FALSE;
   }
   
   IsCursedCheck(lItems = $)
   {
      local bIsCursed, iItem;
	  
	  bIsCursed = FALSE;
	  
      foreach iItem in lItems
      {
         bIsCursed = Send(iItem,@IsCursed);
		    
		 if bIsCursed
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_cursed_equipment);
		    
		    return;
		 }
      }
      
	  return bIsCursed;
   }
   
   IdentifyMasterHolding()
   {
      local lEquipped, iItem, sItemName, bCanIdentify, bDidIdentify, bFake;
	  
	  bDidIdentify = FALSE;
	  
      if piSpellSchool = SS_SHALILLE
	  {
	     lEquipped = Send(poMaster, @GetEquippedItems);
		 
		 if Send(self,@IsCursedCheck,#lItems=lEquipped)
		 {
		    // The master is holding a cursed item, we shouldn't help them until they remove it.
		    return;
		 }
		 
		 foreach iItem in lEquipped
		 {
		    sItemName = Send(iItem,@GetName);
			bCanIdentify = Send(iItem,@CanIdentify) AND Send(iItem,@IsOdd) AND NOT Send(iItem,@IsFake);
			bFake = Send(iItem,@IsFake);
			
			if bFake
			{
			   Post(poMaster,@MsgSendUser,#message_rsc=servant_response_identify_fakse, #parm1=sItemName);
			   
			   return;
			}
			
			if bCanIdentify
			{
			   bDidIdentify = TRUE;
			   
               Post(poMaster,@MsgSendUser,#message_rsc=servant_response_identify_success, #parm1=sItemName);
				   
               Send(poMaster,@SendLook,#what=iItem,#bShow_All=TRUE);
			   
			   return;
			}
         }
		 
		 if NOT bDidIdentify
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_nothing_equipped);
		 }
		 
         return;
	  }
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_wrong_school);
	  
      return;
   }
   
   // A lot of code copied from reveal.kod
   RevealMasterHolding()
   {
      local lEquipped, iItem, sItemName, bCanIdentify, bDidIdentify, lData, iAdvance, oItemAtt, iPower, bFake;
	  
	  bDidIdentify = FALSE;
	  
      if piSpellSchool = SS_SHALILLE
	  {
	     lEquipped = Send(poMaster, @GetEquippedItems);
		 
		 if Send(self,@IsCursedCheck,#lItems=lEquipped)
		 {
		    // The master is holding a cursed item, we shouldn't help them until they remove it.
		    return;
		 }
		 
		 foreach iItem in lEquipped
		 {
		    sItemName = Send(iItem,@GetName);
			bCanIdentify = Send(iItem,@CanIdentify) AND Send(iItem,@IsOdd) AND NOT Send(iItem,@IsFake);
			bFake = Send(iItem,@IsFake);
			
			if bFake
			{
			   Post(poMaster,@MsgSendUser,#message_rsc=servant_response_identify_fakse, #parm1=sItemName);
			   
			   return;
			}
			
			if bCanIdentify
			{
			   bDidIdentify = TRUE;
			   
			   iAdvance = Send(iItem,@RevealHiddenAttributes);

			   // Show newly revealed color
			   if iAdvance
			   {
				  Send(iItem,@RevealHiddenColor);
				  Send(Send(iItem,@GetOwner),@SomethingChanged,#what=iItem);
			   }

               Post(poMaster,@MsgSendUser,#message_rsc=servant_response_reveal_success, #parm1=sItemName);
				   
               Send(poMaster,@SendLook,#what=iItem,#bShow_All=TRUE);

			   lData = Send(iItem,@GetAttributeData,#ItemAtt=IA_MISDIRECTION);

			   if (lData <> $)
			   {
				  oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_MISDIRECTION);
				  iPower = Send(oItemAtt,@TranslatePowerFromCompound,#iCompound=First(lData));

				  if (iPower*2) < piSpellPower
				  {
					 Send(iItem,@RemoveAttribute,#ItemAtt=IA_MISDIRECTION);
				  }
			   }

			   return;
			}
         }
		 
		 if NOT bDidIdentify
		 {
		    Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_nothing_equipped);
		 }
		 
         return;
	  }
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_wrong_school);
	  
      return;
   }

   MendMasterHolding()
   {
      local lEquipped, iItem, sItemName, bCanMend, bDidMend, bHasMendables, bIsCursed, iMaxHits, iHits;
	  
	  bDidMend = FALSE;
	  bHasMendables = FALSE;
	  
      if piSpellSchool = SS_KRAANAN
	  {
	     lEquipped = Send(poMaster, @GetEquippedItems);
		 
		 if Send(self,@IsCursedCheck,#lItems=lEquipped)
		 {
		    // The master is holding a cursed item, we shouldn't help them until they remove it.
		    return;
		 }
		 
		 foreach iItem in lEquipped
		 {
		    sItemName = Send(iItem,@GetName);
			bCanMend = Send(iItem,@CanMend);
			
			if bCanMend
			{
			   bHasMendables = TRUE;
               iHits = Send(iItem,@GetHits);
               iMaxHits = Send(iItem,@GetMaxHits) - 15;
			   
			   if iMaxHits < 100
			   {
			      iMaxHits = 100;
			   }

			   Debug(sItemName,iHits,Send(iItem,@GetMaxHits));
			   
			   if iHits < Send(iItem,@GetMaxHits)
			   {
			      // Mend this item
				  bDidMend = TRUE;
				  
                  Send(iItem,@SetMaxHits,#number=iMaxHits);
                  Send(iItem,@SetHits,#number=iMaxHits);

				  Post(poMaster,@MsgSendUser,#message_rsc=servant_response_mend_success, #parm1=sItemName);
			   }
			}
		 }
		 
		 if NOT bHasMendables
		 {
	        Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_nothing_equipped);
			
		    return;
		 }
		 
		 if NOT bDidMend
		 {
	        Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_perfect_items);
			
		    return;
		 }
		 
         return;
	  }
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_wrong_school);
	  
      return;
   }
   
   DisguiseMaster()
   {
      local oSpell;
	  
      if piSpellSchool = SS_RIIJA
	  {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_ILLUSIONARY_FORM);
		 
         Send(oSpell,@CastSpell,#who=poMaster,#lTargets=[poMaster],#iSpellPower=piSpellPower);
		 
         return;
	  }
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_wrong_school);
	  
      return;
   }
   
   BaitMonsters()
   {
      local oSpell;
	  
      if piSpellSchool = SS_RIIJA
	  {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_BAIT);
		 
         Send(oSpell,@CastSpell,#who=poMaster,#lTargets=[self],#iSpellPower=piSpellPower);

         return;
	  }
	  
	  Post(poMaster,@MsgSendUser,#message_rsc=servant_tells_you_rsc, #parm1=servant_response_wrong_school);
	  
      return;
   }

end
////////////////////////////////////////////////////////////////////////////////
