// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.


////////////////////////////////////////////////////////////////////////////////
DeathRealm is MonsterRoom

constants:

   include blakston.khd

resources:

   room_name_DeathRealm ="Death Realm"
   death_realm_no_cast_rsc = "The forces of Qor prevent you from using that magic here. "

   // Lava Damage
   Lava_damage_no_hurt = "You walk through the lava as if you were a god."
   Lava_damage_hurt = "As you wade through the lava it burns you violently."      
   Lava_scratch_snd = frying.ogg

   // Heat Damage
   Heat_damage_hurt = "You feel your skin burn by the overwhelming heat."

   // Quake Damage
   Quake_damage_hurt = "You feel the earth beneath you move violently."

   Needs_Key = "You need a key for this door, ask the town folk for help."

   DeathRealm_music = drmusic.mp3

classvars:

   vrName = room_name_DeathRealm
   viWeatherZone = WEATHER_ZONE_RAZA
   viWeatherMask = WEATHER_MASK_DEFAULT_NS

properties:

   prBackground = background_chaos_night
   prMusic = DeathRealm_music

   piBaseLight = LIGHT_MIN
   piOutside_factor = 0

   plGenerators = $
   piMonster_count_max = 30
   piInit_count_min = 5
   piInit_count_max = 10
   
   // Lava damage
   piLava_damage = 5
   piLava_interval = 1000
   
   // Heat damage
   piHeat_damage_min = 1
   piHeat_damage_max = 2
   piHeat_interval = 3000
   piHeat_notice = 30000
   
   // Earthquake damage
   piQuake_damage_min = 3
   piQuake_damage_max = 10
   piQuake_interval = 1800000
   
   // Fire Ring
   piFireRing_interval = 10000
   
   //Toggels
   prMapChanges = TRUE
   prMonsters = TRUE
   prHeat = TRUE
   prQuake = TRUE
   prFireRing = TRUE
   
messages:

   Constructed()
   {
      if prMapChanges = TRUE
      {
         Send(self,@ChangeTexture,#id=10,#new_texture=03203,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=11,#new_texture=03203,#flags=CTF_BELOWWALL);
         Send(self,@ChangeTexture,#id=0,#new_texture=09738,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=5,#new_texture=09738,#flags=CTF_FLOOR);
         Send(self,@ChangeTexture,#id=15,#new_texture=09738,#flags=CTF_BELOWWALL);
      }

      if prMonsters = TRUE
      {
         plMonsters = [ [&HeadlessSkeleton, 7],
                        [&Spirit, 7],
                        [&Revenantb, 7],
                        [&Chimera, 7],
                        [&Cyclops, 7],
                        [&FollowerOfQor, 7],
                        [&MinotaurBerserker, 6],
                        [&Tyrant, 6],
                        [&FallenMonk, 6],
                        [&HellWasp, 6],
                        [&Croco, 6],
                        [&Vozun, 6],
                        [&Dulahan, 6],
                        [&BlackHydra, 6],
                        [&RedHydra, 6],
                        [&GoldHydra, 6],
                        [&GreenHydra, 6],
                        [&GreySeeker, 6],
                        [&GreenSeeker, 6],
                        [&BrownSeeker, 6],
                        [&DeathMiteSoldier, 6],
                        [&DeathMiteScout, 6],
                        [&DeathMiteTank, 6],
                        [&DeathMiteMage, 6]
                         ];
      }

      propagate;
   }
   
   RecalcBackgroundSkyGraphic(iSkyBox=0)
   {
      return;
   }

   GetRoomLight()
   {
      local iLight;

      return iLight=0;
   }

   ReqSpellCast(who = $, oSpell = $, lItems = $)
   {
      if IsClass(who, &DM)
	  {
	     return TRUE;
	  }
	  
      if IsClass(oSpell,&Elusion)
         OR IsClass(oSpell,&Rescue)
         OR IsClass(oSpell,&DeathRift)
         OR IsClass(oSpell,&Truce)
         OR IsClass(oSpell,&Jig)
         OR IsClass(oSpell,&NightVision)
         OR IsClass(oSpell,&MartyrsBattleground)
         OR IsClass(oSpell,&Anonymity)
         OR IsClass(oSpell,&ForcesOfLight)
         OR IsClass(oSpell,&QorBane)
         OR IsClass(oSpell,&PortalofLife)
         OR IsClass(oSpell,&FinalRites)
         OR IsClass(oSpell,&BrambleWall)
         OR IsClass(oSpell,&Seduce)
      {
         // We have to provide the fail message here.
         Send(who,@MsgSendUser,#message_rsc=death_realm_no_cast_rsc,
               #parm1=Send(oSpell,@GetName));

         return FALSE;
      }

      propagate;
   }

   SomethingMoved(what = $, new_row = $, new_col = $, fine_row = FINENESS/2,
                  fine_col = FINENESS/2, cause = CAUSE_UNKNOWN, speed = 0,
                  non_monsters_only = FALSE)
   {
      local i, temp, each_obj, packet_built, lNode, iQflags, 
            iRflags, iHeightF, iHeightFWD, iHeightC, iServerID, session;

      if (IsClass(what, &User)) {
	     session = Send(what,@GetSession);
         lUser_pos = [Send(self,@GetTeleportAngle),new_row,new_col,fine_row,fine_col,session];
	  }

      propagate;
   }

   NewHold(what = $, new_angle = ANGLE_EAST, new_row = 1, new_col = 1,
           fine_row = FINENESS/2, fine_col = FINENESS/2, session = $,
           merge = TRUE)
   {
      local bUser;

      if what = $
         OR what = self
      {
         return;
      }

      bUser = IsClass(what,&User);
	  
	  if (bUser) {
         pbUser = what;
	  }

      if bUser
      {
		 if (bUser AND ptLava_damage = $) {
		    ptLava_damage = CreateTimer(self, @CheckForLavaDamage, piLava_interval);
		 }
		 if (bUser AND ptHeat_damage = $) {
		    ptHeat_damage = CreateTimer(self, @HeatDamageTimer, piHeat_interval);
		 }
		 if (bUser AND ptQuake_damage = $) {
		    ptQuake_damage = CreateTimer(self, @QuakeDamageTimer, piQuake_interval);
		 }
		 if (bUser AND ptFireRing_damage = $) {
		    ptFireRing_damage = CreateTimer(self, @FireRingTimer, piFireRing_interval);
		 }
      }

      propagate;
   }

   LastUserLeft()
   {
      if (ptLava_damage <> $)
      {
		 DeleteTimer(ptLava_damage);
         ptLava_damage = $;
      }

      if (ptHeat_damage <> $)
      {
		 DeleteTimer(ptHeat_damage);
         ptHeat_damage = $;
      }

      if (ptQuake_damage <> $)
      {
		 DeleteTimer(ptQuake_damage);
         ptQuake_damage = $;
      }

      if (ptFireRing_damage <> $)
      {
		 DeleteTimer(ptFireRing_damage);
         ptFireRing_damage = $;
      }

      propagate;
   }

   Delete()
   {
      if (ptLava_damage <> $)
      {
		 DeleteTimer(ptLava_damage);
         ptLava_damage = $;
      }

      if (ptHeat_damage <> $)
      {
		 DeleteTimer(ptHeat_damage);
         ptHeat_damage = $;
      }

      if (ptQuake_damage <> $)
      {
		 DeleteTimer(ptQuake_damage);
         ptQuake_damage = $;
      }

      if (ptFireRing_damage <> $)
      {
		 DeleteTimer(ptFireRing_damage);
         ptFireRing_damage = $;
      }

      propagate;
   }
   
   CheckForLavaDamage()
   {
      local iSectorID;
      
	  ptLava_damage = $;
      ptLava_damage = CreateTimer(self, @CheckForLavaDamage, piLava_interval);
	  
      if (pbUser = $ OR lUser_pos = $) {
	     return;
	  }

	  iSectorID = Send(self,@GetSectorIDAtLocation,#row=Nth(lUser_pos,2),
		  		  #col=Nth(lUser_pos,3),#fine_row=Nth(lUser_pos,4),
				  #fine_col=Nth(lUser_pos,5));
				  
      if (iSectorID = 10)
	  {
	     // Burn the player with lava...
		 Send(self, @BurnPerson, #what=pbUser);
	  }
	  
	  return;
   }
   
   BurnPerson(what = $)
   {
      if (what <> $ AND IsClass(what, &Player) AND NOT IsClass(what, &DM))
      {
		 Send(what,@LoseHealth,#amount=piLava_damage,#precision=FALSE);
         Send(what,@WaveSendUser,#wave_rsc=Lava_scratch_snd);
		 Send(what,@MsgSendUser,#message_rsc=Lava_damage_hurt);
      }

      if (what <> $ AND IsClass(what, &DM))
      {
         Send(what,@WaveSendUser,#wave_rsc=Lava_scratch_snd);
		 Send(what,@MsgSendUser,#message_rsc=Lava_damage_no_hurt);
      }
	  
      return;
   }
   
   HeatDamageTimer()
   {
	  ptHeat_damage = $;
      ptHeat_damage = CreateTimer(self, @HeatDamageTimer, piHeat_interval);
   	  
      if (pbUser = $) 
      {
	     return;
	  }
	   
      if prHeat = TRUE
	  {
	      // Do heat damage on player...
         Send(self, @DoHeatDamage, #what=pbUser);

         return;
      }
	  
	  return;
   }
   
   QuakeDamageTimer()
   {
	  ptQuake_damage = $;
      ptQuake_damage = CreateTimer(self, @QuakeDamageTimer, piQuake_interval);
   	  
      if (pbUser = $) 
      {
	     return;
	  }
	  
      if prQuake = TRUE
	   {
	      // Do Quake damage on player...
          Send(self, @DoQuakeDamage, #what=pbUser);

          return;
      }
	  
	  return;
   }

   DoHeatDamage(what = $)
   {
      if (what <> $ AND IsClass(what, &Player) AND NOT IsClass(what, &DM))
      {
		 Send(what,@LoseHealth,#amount=Random(piHeat_damage_min, piHeat_damage_max),#precision=FALSE);
         
		 piHeat_notice += 1000;
		 
		 if (piHeat_notice > 30000)
		 {
		    Send(what,@MsgSendUser,#message_rsc=Heat_damage_hurt);
			piHeat_notice = 0;
		 }
      }

      return;
   }
   
   DoQuakeDamage(what = $)
   {
      if (what <> $ AND IsClass(what, &Player) AND NOT IsClass(what, &DM))
      {
		 Send(what,@LoseHealth,#amount=Random(piQuake_damage_min, piQuake_damage_max),#precision=FALSE);
         Send(what,@MsgSendUser,#message_rsc=Quake_damage_hurt);
		 Post(self,@Rumble,#duration=3000,#disruption=100);
      }

      return;
   }

   FireRingTimer()
   {
	  ptFireRing_damage = $;
      ptFireRing_damage = CreateTimer(self, @FireRingTimer, piFireRing_interval);
   	  
      if (pbUser = $) 
      {
	     return;
	  }
	  
      if prFireRing = TRUE
	   {
          Send(self, @PlaceRingOfFlames, #who=pbUser, #iSpellPower=99);

          return;
      }
	  
	  return;
   }

   PlaceRingOfFlames(who=$,iSpellPower=1)
   {
      local iRow, iCol, iFine_Row, iFine_Col, iXStep, iYStep,
            iAngle, iMaxDamage, iDuration, iHalfrow, iHalfCol, iHalfFine_Row,
            iHalfFine_Col, oElement;

      iAngle = ANGLE_EAST;
      iMaxDamage = iSpellPower / 5;
      iMaxDamage = Bound(iMaxDamage,1,20);
      iDuration = (iSpellPower * 2) + 30;
      iDuration = Bound(iDuration,30,90);

      iRow = Random(1, piRows);
      iCol = Random(1, piCols);

      // Create fire in eight cardinal directions
      oElement = Create(&WallofFire,#Caster=$,#MaxDamage=iMaxDamage,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=(iRow+1),#new_col=(iCol+1),
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=(iRow+1),#new_col=iCol,
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=(iRow+1),#new_col=(iCol-1),
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=iRow,#new_col=(iCol+1),
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=iRow,#new_col=(iCol-1),
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=(iRow-1),#new_col=(iCol+1),
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=(iRow-1),#new_col=iCol,
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);

      oElement = Create(&WallofFire,#MaxDamage=iMaxDamage,#Caster=$,
                        #Duration=iDuration);
      Send(self,@NewHold,#what=oElement,#new_row=(iRow-1),#new_col=(iCol-1),
           #fine_row=FINENESS_HALF,#fine_col=FINENESS_HALF);


      // Create four "filler" elements in corners.
      oElement = Create(&PassiveWallofFire,#Caster=$,#MaxDamage=iMaxDamage,
                        #Duration=iDuration,#Illusionary=FALSE);
      Send(self,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
           #fine_row=0,#fine_col=0);

      oElement = Create(&PassiveWallofFire,#Caster=$,#MaxDamage=iMaxDamage,
                        #Duration=iDuration,#Illusionary=FALSE);
      Send(self,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
           #fine_row=0,#fine_col=FINENESS);

      oElement = Create(&PassiveWallofFire,#Caster=$,#MaxDamage=iMaxDamage,
                        #Duration=iDuration,#Illusionary=FALSE);
      Send(self,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
           #fine_row=FINENESS,#fine_col=0);

      oElement = Create(&PassiveWallofFire,#Caster=$,#MaxDamage=iMaxDamage,
                        #Duration=iDuration,#Illusionary=FALSE);
      Send(self,@NewHold,#what=oElement,#new_row=iRow,#new_col=iCol,
           #fine_row=FINENESS,#fine_col=FINENESS);

      return;
   }

end
////////////////////////////////////////////////////////////////////////////////
